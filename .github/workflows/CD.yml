name: CD Pipeline

#on:
#  workflow_run:
#    workflows: [ "CI Pipeline" ]
#    types:
#      - completed
#  push:
#     branches:
#       - main

on:
  workflow_dispatch:  # manual trigger

jobs:
  deploy:
#    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: self-hosted
    permissions:
      contents: write   # needed to push commits with GITHUB_TOKEN (or use PAT)
    env:
      REPO_URL: "https://github.com/karty11/New_project.git"
      # IMAGE_TAG will be set to the github.sha of the run that triggered this workflow (workflow_run object)
      IMAGE_TAG: ${{ github.event.workflow_run.head_commit.id || github.sha }}
    steps:

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: true

      - name: Install AWS CLI v2
        run: |
            if ! command -v aws >/dev/null 2>&1; then
              curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
              unzip -q awscliv2.zip
              sudo ./aws/install
            else
              echo "aws already installed: $(aws --version)"
            fi    

      - name: Ensure tools (kubectl, helm, yq, argocd CLI)
        run: |
          # kubectl
          if ! command -v kubectl >/dev/null 2>&1; then
            echo "kubectl not found - installing via azure/setup-kubectl action would be better"
            exit 1
          fi
          # helm
          if ! command -v helm >/dev/null 2>&1; then
            echo "helm not found - installing via azure/setup-helm action would be better"
            exit 1
          fi
          # yq (install if missing)
          if ! command -v yq >/dev/null 2>&1; then
            sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
            sudo chmod +x /usr/local/bin/yq
          fi
         

      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-west-2


      - name: Ensure kubectl is present
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Prepare kubeconfig path (persist for next steps)
        run: |
          mkdir -p ~/.kube
          chmod 700 ~/.kube
          # persist KUBECONFIG for all following steps
          echo "KUBECONFIG=$HOME/.kube/config" >> $GITHUB_ENV
          echo "KUBECONFIG set to $HOME/.kube/config (persisted to GITHUB_ENV)"

#      - name:
#          Debug: show aws & env (quick check)
#        run: |
#          echo "aws version: $(aws --version 2>&1 || true)"
#          echo "GITHUB_ENV KUBECONFIG: $KUBECONFIG"
#          aws sts get-caller-identity --output text || echo "sts identity failed"
#          aws eks describe-cluster --name project-cluster --region us-west-2 --query "cluster.endpoint" --output text || echo "describe-cluster failed (permissions/network)"

      - name: Update kubeconfig for EKS (write to ~/.kube/config)
        run: |
          set -euo pipefail
          # KUBECONFIG is now available from GITHUB_ENV
          echo "Using KUBECONFIG=$KUBECONFIG"
          if ! aws sts get-caller-identity >/dev/null 2>&1; then
            echo "AWS credentials not working - aborting"
            aws sts get-caller-identity || true
            exit 2
          fi
          # Force write to the explicit path (no chance of empty var)
          aws eks update-kubeconfig --region us-west-2 --name project-cluster --kubeconfig "$KUBECONFIG"
          echo "Wrote kubeconfig to $KUBECONFIG"
          ls -l "$KUBECONFIG" || true
          sed -n '1,60p' "$KUBECONFIG" || true

      - name: Verify Kubernetes cluster
        run: |
          kubectl version --output=yaml
          kubectl cluster-info || true
          kubectl get nodes --no-headers -o wide

      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.13.1

      - name: Install Terragrunt
        run: |
          curl -L https://github.com/gruntwork-io/terragrunt/releases/download/v0.67.4/terragrunt_linux_amd64 -o terragrunt
          chmod +x terragrunt
          sudo mv terragrunt /usr/local/bin/

      - name: Check versions
        run: |
          terraform -version
          terragrunt -version

      - name: Add Argo Helm repo & update
        run: |
          helm repo add argo https://argoproj.github.io/argo-helm || true
          helm repo update

      - name: Create argocd namespace
        run: |
          kubectl create ns argocd || echo "namespace argocd already exists"

#      - name: Install/Upgrade Argo CD via Helm (idempotent)
#        run: |
#          helm upgrade --install argocd argo/argo-cd \
#            --namespace argocd \
#            --version 7.6.9 \
#            -f deploy/argocd/argocd-values.yaml \
#            --kubeconfig "$KUBECONFIG" \
#            --wait --timeout 10m
      - name: Install Argo CD via Helm
        run: |
            helm upgrade --install argocd argo/argo-cd \
             --namespace argocd --create-namespace \
             --values helm/bankapp-chart/argocd-values.yaml

      - name: Wait for argocd components ready (server may be ClusterIP or LB)
        run: |
          kubectl -n argocd rollout status deployment/argocd-server --timeout=120s || true
          kubectl -n argocd rollout status deployment/argocd-repo-server --timeout=120s || true
          kubectl -n argocd rollout status deployment/argocd-application-controller --timeout=120s || true

      - name: Install Argo CD CLI
        run: |
          curl -sSL -o argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
          chmod +x argocd
          sudo mv argocd /usr/local/bin/argocd

      - name: Trigger Argo CD sync
        env:
          ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER }}
          ARGOCD_AUTH_TOKEN: ${{ secrets.ARGOCD_AUTH_TOKEN }}
        run: |
          if [ -n "$ARGOCD_SERVER" ] && [ -n "$ARGOCD_AUTH_TOKEN" ]; then
            argocd app sync bankapp \
              --server "$ARGOCD_SERVER" \
              --auth-token "$ARGOCD_AUTH_TOKEN" \
              --grpc-web --insecure --wait
          else
            echo "Skipping ArgoCD sync (missing secrets)"
          fi

      - name: Compute target branch
        id: branch
        run: |
          BRANCH="${GITHUB_REF_NAME:-$(jq -r '.workflow_run.head_branch' <<<"$GITHUB_EVENT_PAYLOAD")}"
          if [ -z "$BRANCH" ] || [ "$BRANCH" = "null" ]; then
            BRANCH="main"
          fi
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT

      - name: Apply Argo CD Application manifest
        run: |
          kubectl apply -f manifests/argocd-app-bankapp.yaml

      - name: Show created manifest (debug)
        run: |
         echo "==== manifests/argocd-app-bankapp.yaml ===="
         cat manifests/argocd-app-bankapp.yaml
         echo "==========================================="

      - name: Update Helm values.yaml with new image tag
        env:
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
        run: |
            # Ensure file exists
            if [ ! -f helm/bankapp-chart/values.yaml ]; then
              echo "ERROR: helm/bankapp-chart/values.yaml not found"
              exit 1
            fi
            
            # Update image.tag (works if structure is image: { repository, tag })
            yq e -i '.image.tag = strenv(IMAGE_TAG)' helm/bankapp-chart/values.yaml
            git add helm/bankapp-chart/values.yaml
            
            if git diff --cached --quiet; then
              echo "No change to values.yaml (image tag already up-to-date)."
            else
              git commit -m "ci: bump bankapp image tag to ${IMAGE_TAG}"
              if [ -n "${{ secrets.PERSONAL_ACCESS_TOKEN }}" ]; then
                git remote set-url origin https://x-access-token:${{ secrets.PERSONAL_ACCESS_TOKEN }}@github.com/${{ github.repository }}.git
              fi
              git push origin HEAD:${BRANCH}
              echo "Pushed updated values.yaml with image tag ${IMAGE_TAG}."
            fi

      - name: Print Argo CD initial admin password (for reference)
        run: |
         echo "Argo CD initial admin password (if autogenerated):"
         kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d || echo "secret not found yet"

      
